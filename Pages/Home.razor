@page "/"

@inject IJSRuntime JSRuntime

<PageTitle>Ghoti Translator</PageTitle>

<h1 class="text-center">Ghoti Translator</h1>

<div class="form-group">
    <h2>Input</h2>

    <textarea @bind="InputText" placeholder="Enter text to translate" class="form-control mb-2"></textarea>
    <button @onclick="Translate" class="btn btn-primary">Translate</button>
</div>


<div class="form-group">
    <h2>Translation</h2>

    <textarea @bind="TranslatedText" placeholder="Translated result will go here" readonly class="form-control mb-2"></textarea>
    <button @onclick="CopyToClipboard" class="btn btn-dark">Copy</button>
</div>


@* Idea/TODO: consider making this hoverable/highlightable as a pop-up word by word in the translated text section above *@
@if (TranslatedText.Length > 0) {
    <div>
        <h3>Spelling rules used</h3>

        @if (usedRules.Count == 0)
        {
            <p>No conversion rules used</p>
        } 
        
        else {
            <ul>
                @* TODO: work on how this is shown, make it easier to show either way of the translation *@
                @foreach (var rule in usedRules) {
                    if (spellingRules.ContainsKey(rule) && pronunciationRules.ContainsKey(rule)) {
                        <li><span>@rule</span>  <span>@pronunciationRules[rule]</span></li>
                    }
                    else if (spellingRules.ToDictionary(x => x.Value, x => x.Key).ContainsKey(rule)) {
                        <li><span>@rule</span>  <span>@pronunciationRules[spellingRules.ToDictionary(x => x.Value, x => x.Key)[rule]]</span></li>
                    }
                }
            </ul>
        }
    </div>
}

<div>
    <h4>Explanation/Disclaimer:</h4>
    <p>
        This is a fun project to demonstrate how the English language can be confusing. The rules used here are not exhaustive and are not accurate in many cases.
        This is because normally the 'ghoti' rules are based off IPA sounds, not English spelling. Maybe this will be added in the future...
    </p>

    <p class="mt-2">
        For more reading, see the below resources:
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Ghoti" target="_blank">Wikipedia - Ghoti</a></li>
            <li><a href="https://www.youtube.com/watch?v=3ipFdRfFvK4" target="_blank">Vsauce - Forbidden Spellings</a></li>
        </ul>
    </p>
</div>

@code {
    private string InputText { get; set; } = string.Empty;
    private string TranslatedText { get; set; } = string.Empty;

    private HashSet<string> usedRules = new HashSet<string>();

    @* TODO: expand on this list *@
    private Dictionary<string, string> spellingRules = new Dictionary<string, string>
    {
        { "gh", "f" },
        { "o", "i" },
        { "ti", "sh" }
    };


    @* TODO: expand on this list, find out if it necessarily works both ways? *@
    @* TODO: make this work for when accessed via reversed spellingRules (see else if statement in "Spelling rules used" section) *@
    private Dictionary<string, string> pronunciationRules = new Dictionary<string, string>
        {
            { "gh", "becomes the \"f\" sound in \"enough\"" },
            { "o", "becomes the \"i\" sound in \"women\"" },
            { "ti", "becomes the \"sh\" sound in \"nation\"" }
        };

     private void Translate()
    {
        TranslatedText = string.Empty;
        int i = 0;

        // Create a reverse mapping for bidirectional translation
        Dictionary<string, string> reverseRules = spellingRules.ToDictionary(kvp => kvp.Value, kvp => kvp.Key);

        usedRules.Clear();

        while (i < InputText.Length)
        {
            bool matched = false;

            // Check both dictionaries for longest matches first
            foreach (var rule in spellingRules.Concat(reverseRules).OrderByDescending(r => r.Key.Length))
            {
                if (i + rule.Key.Length <= InputText.Length && InputText.Substring(i, rule.Key.Length) == rule.Key)
                {
                    TranslatedText += rule.Value;
                    usedRules.Add(rule.Key);
                    i += rule.Key.Length; // Skip past the matched sequence
                    matched = true;
                    break;
                }
            }

            // If no match found, just add the current character
            if (!matched)
            {
                TranslatedText += InputText[i];
                i++;
            }
        }

        Console.WriteLine($"Translated text: {TranslatedText}, from original: {InputText}");

        Console.WriteLine("Spelling rules used: {0}", String.Join(',', usedRules));
        
    }

    private void CopyToClipboard()
    {
        Console.WriteLine("Copying to clipboard");
        Console.WriteLine(JSRuntime.InvokeVoidAsync("CopyToClipboard.copyToClipboard", TranslatedText));
    }
}